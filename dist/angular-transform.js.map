{
  "version": 3,
  "sources": ["../src/angular-transform.ts"],
  "sourcesContent": ["/**\n * Angular Template Transform\n *\n * Injects source location data into Angular template elements,\n * enabling click-to-source functionality.\n *\n * Supports:\n * - External templates (.component.html files)\n * - Inline templates in .component.ts files\n */\n\nexport interface AngularTransformOptions {\n  filename: string;\n  ignoreComponentNames?: string[];\n}\n\n// Elements to skip (Angular structural directives, ng-container, etc.)\nconst SKIP_ELEMENTS = new Set([\n  \"ng-container\",\n  \"ng-template\",\n  \"ng-content\",\n  \"router-outlet\",\n]);\n\n// Self-closing HTML elements\nconst VOID_ELEMENTS = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n]);\n\n/**\n * Transform an Angular HTML template to inject source locations\n */\nexport function transformAngularTemplate(\n  code: string,\n  options: AngularTransformOptions\n): { code: string; map?: any } | null {\n  const { filename, ignoreComponentNames = [] } = options;\n\n  // Simple regex-based approach for Angular templates\n  // Matches opening tags: <tagName ...>\n  const tagRegex = /<([a-zA-Z][a-zA-Z0-9-]*)((?:\\s+[^>]*)?)\\s*(\\/?)>/g;\n\n  let result = \"\";\n  let lastIndex = 0;\n  let lineNumber = 1;\n  let lineStart = 0;\n  let modified = false;\n\n  // Build a line map for calculating line numbers\n  const lineBreaks: number[] = [0];\n  for (let i = 0; i < code.length; i++) {\n    if (code[i] === \"\\n\") {\n      lineBreaks.push(i + 1);\n    }\n  }\n\n  function getLineAndColumn(offset: number): { line: number; column: number } {\n    let line = 1;\n    for (let i = 0; i < lineBreaks.length; i++) {\n      if (lineBreaks[i] > offset) {\n        break;\n      }\n      line = i + 1;\n    }\n    const column = offset - lineBreaks[line - 1];\n    return { line, column };\n  }\n\n  let match;\n  while ((match = tagRegex.exec(code)) !== null) {\n    const [fullMatch, tagName, attributes, selfClosing] = match;\n    const matchStart = match.index;\n\n    // Skip elements we shouldn't modify\n    if (\n      SKIP_ELEMENTS.has(tagName.toLowerCase()) ||\n      ignoreComponentNames.includes(tagName)\n    ) {\n      continue;\n    }\n\n    // Skip if already has data-locatorjs\n    if (attributes && attributes.includes(\"data-locatorjs\")) {\n      continue;\n    }\n\n    // Skip comments\n    if (tagName.startsWith(\"!\")) {\n      continue;\n    }\n\n    // Calculate line and column\n    const { line, column } = getLineAndColumn(matchStart);\n    const locatorValue = `${filename}:${line}:${column}`;\n\n    // Determine where to insert the attribute\n    // Insert before the closing > or />\n    const insertPos = matchStart + fullMatch.length - (selfClosing ? 2 : 1);\n\n    // Build the new code\n    result += code.slice(lastIndex, insertPos);\n    result += ` data-locatorjs=\"${locatorValue}\"`;\n    result += code.slice(insertPos, matchStart + fullMatch.length);\n\n    lastIndex = matchStart + fullMatch.length;\n    modified = true;\n  }\n\n  if (!modified) {\n    return null;\n  }\n\n  // Append remaining code\n  result += code.slice(lastIndex);\n\n  return { code: result };\n}\n\n/**\n * Transform an Angular component file with inline template\n */\nexport function transformAngularComponent(\n  code: string,\n  filename: string,\n  options: { ignoreComponentNames?: string[] } = {}\n): { code: string; map?: any } | null {\n  // Find inline template in @Component decorator\n  // Matches: template: `...` or template: '...' or template: \"...\"\n  const templateRegex =\n    /template\\s*:\\s*(`(?:[^`\\\\]|\\\\.)*`|'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\")/g;\n\n  let result = code;\n  let modified = false;\n  let offset = 0;\n\n  let match;\n  while ((match = templateRegex.exec(code)) !== null) {\n    const [fullMatch, templateLiteral] = match;\n    const matchStart = match.index + offset;\n\n    // Extract template content (remove quotes/backticks)\n    const quote = templateLiteral[0];\n    const templateContent = templateLiteral.slice(1, -1);\n\n    // Calculate the offset where the template content starts in the original file\n    const templateStartInFile = match.index + fullMatch.indexOf(templateLiteral) + 1;\n\n    // Transform the template\n    const transformed = transformAngularTemplate(templateContent, {\n      filename,\n      ignoreComponentNames: options.ignoreComponentNames,\n    });\n\n    if (transformed) {\n      // Reconstruct with the transformed template\n      const before = result.slice(0, matchStart + fullMatch.indexOf(templateLiteral));\n      const after = result.slice(matchStart + fullMatch.indexOf(templateLiteral) + templateLiteral.length);\n\n      const newTemplateLiteral = quote + transformed.code + quote;\n      result = before + newTemplateLiteral + after;\n\n      // Adjust offset for subsequent matches\n      offset += newTemplateLiteral.length - templateLiteral.length;\n      modified = true;\n    }\n  }\n\n  if (!modified) {\n    return null;\n  }\n\n  return { code: result };\n}\n\n/**\n * Transform Angular files (both .html templates and .ts components)\n */\nexport function transformAngularFile(\n  code: string,\n  filename: string,\n  options: { ignoreComponentNames?: string[] } = {}\n): { code: string; map?: any } | null {\n  if (filename.endsWith(\".html\")) {\n    return transformAngularTemplate(code, { filename, ...options });\n  }\n\n  if (filename.endsWith(\".ts\") && code.includes(\"@Component\")) {\n    return transformAngularComponent(code, filename, options);\n  }\n\n  return null;\n}\n"],
  "mappings": "AAiBA,MAAM,gBAAgB,oBAAI,IAAI;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAGD,MAAM,gBAAgB,oBAAI,IAAI;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAKM,SAAS,yBACd,MACA,SACoC;AACpC,QAAM,EAAE,UAAU,uBAAuB,CAAC,EAAE,IAAI;AAIhD,QAAM,WAAW;AAEjB,MAAI,SAAS;AACb,MAAI,YAAY;AAChB,MAAI,aAAa;AACjB,MAAI,YAAY;AAChB,MAAI,WAAW;AAGf,QAAM,aAAuB,CAAC,CAAC;AAC/B,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,QAAI,KAAK,CAAC,MAAM,MAAM;AACpB,iBAAW,KAAK,IAAI,CAAC;AAAA,IACvB;AAAA,EACF;AAEA,WAAS,iBAAiB,QAAkD;AAC1E,QAAI,OAAO;AACX,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,UAAI,WAAW,CAAC,IAAI,QAAQ;AAC1B;AAAA,MACF;AACA,aAAO,IAAI;AAAA,IACb;AACA,UAAM,SAAS,SAAS,WAAW,OAAO,CAAC;AAC3C,WAAO,EAAE,MAAM,OAAO;AAAA,EACxB;AAEA,MAAI;AACJ,UAAQ,QAAQ,SAAS,KAAK,IAAI,OAAO,MAAM;AAC7C,UAAM,CAAC,WAAW,SAAS,YAAY,WAAW,IAAI;AACtD,UAAM,aAAa,MAAM;AAGzB,QACE,cAAc,IAAI,QAAQ,YAAY,CAAC,KACvC,qBAAqB,SAAS,OAAO,GACrC;AACA;AAAA,IACF;AAGA,QAAI,cAAc,WAAW,SAAS,gBAAgB,GAAG;AACvD;AAAA,IACF;AAGA,QAAI,QAAQ,WAAW,GAAG,GAAG;AAC3B;AAAA,IACF;AAGA,UAAM,EAAE,MAAM,OAAO,IAAI,iBAAiB,UAAU;AACpD,UAAM,eAAe,GAAG,QAAQ,IAAI,IAAI,IAAI,MAAM;AAIlD,UAAM,YAAY,aAAa,UAAU,UAAU,cAAc,IAAI;AAGrE,cAAU,KAAK,MAAM,WAAW,SAAS;AACzC,cAAU,oBAAoB,YAAY;AAC1C,cAAU,KAAK,MAAM,WAAW,aAAa,UAAU,MAAM;AAE7D,gBAAY,aAAa,UAAU;AACnC,eAAW;AAAA,EACb;AAEA,MAAI,CAAC,UAAU;AACb,WAAO;AAAA,EACT;AAGA,YAAU,KAAK,MAAM,SAAS;AAE9B,SAAO,EAAE,MAAM,OAAO;AACxB;AAKO,SAAS,0BACd,MACA,UACA,UAA+C,CAAC,GACZ;AAGpC,QAAM,gBACJ;AAEF,MAAI,SAAS;AACb,MAAI,WAAW;AACf,MAAI,SAAS;AAEb,MAAI;AACJ,UAAQ,QAAQ,cAAc,KAAK,IAAI,OAAO,MAAM;AAClD,UAAM,CAAC,WAAW,eAAe,IAAI;AACrC,UAAM,aAAa,MAAM,QAAQ;AAGjC,UAAM,QAAQ,gBAAgB,CAAC;AAC/B,UAAM,kBAAkB,gBAAgB,MAAM,GAAG,EAAE;AAGnD,UAAM,sBAAsB,MAAM,QAAQ,UAAU,QAAQ,eAAe,IAAI;AAG/E,UAAM,cAAc,yBAAyB,iBAAiB;AAAA,MAC5D;AAAA,MACA,sBAAsB,QAAQ;AAAA,IAChC,CAAC;AAED,QAAI,aAAa;AAEf,YAAM,SAAS,OAAO,MAAM,GAAG,aAAa,UAAU,QAAQ,eAAe,CAAC;AAC9E,YAAM,QAAQ,OAAO,MAAM,aAAa,UAAU,QAAQ,eAAe,IAAI,gBAAgB,MAAM;AAEnG,YAAM,qBAAqB,QAAQ,YAAY,OAAO;AACtD,eAAS,SAAS,qBAAqB;AAGvC,gBAAU,mBAAmB,SAAS,gBAAgB;AACtD,iBAAW;AAAA,IACb;AAAA,EACF;AAEA,MAAI,CAAC,UAAU;AACb,WAAO;AAAA,EACT;AAEA,SAAO,EAAE,MAAM,OAAO;AACxB;AAKO,SAAS,qBACd,MACA,UACA,UAA+C,CAAC,GACZ;AACpC,MAAI,SAAS,SAAS,OAAO,GAAG;AAC9B,WAAO,yBAAyB,MAAM,EAAE,UAAU,GAAG,QAAQ,CAAC;AAAA,EAChE;AAEA,MAAI,SAAS,SAAS,KAAK,KAAK,KAAK,SAAS,YAAY,GAAG;AAC3D,WAAO,0BAA0B,MAAM,UAAU,OAAO;AAAA,EAC1D;AAEA,SAAO;AACT;",
  "names": []
}

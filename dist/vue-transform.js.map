{
  "version": 3,
  "sources": ["../src/vue-transform.ts"],
  "sourcesContent": ["/**\n * Vue SFC Template Transform\n *\n * Injects source location data into Vue template elements,\n * enabling click-to-source functionality.\n */\n\nimport type {\n  ElementNode,\n  RootNode,\n  TemplateChildNode,\n  AttributeNode,\n} from \"@vue/compiler-core\";\n\nexport interface VueTransformOptions {\n  filename: string;\n  ignoreComponentNames?: string[];\n}\n\nconst DISALLOWED_TAGS = new Set([\n  \"template\",\n  \"slot\",\n  \"component\",\n  \"transition\",\n  \"transition-group\",\n  \"keep-alive\",\n  \"teleport\",\n  \"suspense\",\n]);\n\n/**\n * Check if an element should be skipped\n */\nfunction shouldSkipElement(\n  tag: string,\n  ignoreComponentNames: string[]\n): boolean {\n  if (DISALLOWED_TAGS.has(tag)) return true;\n  if (ignoreComponentNames.includes(tag)) return true;\n  // Skip Vue's built-in dynamic component\n  if (tag === \"Component\") return true;\n  return false;\n}\n\n/**\n * Transform a Vue template AST to inject source location attributes\n */\nexport function transformVueTemplate(\n  ast: RootNode,\n  options: VueTransformOptions\n): void {\n  const { filename, ignoreComponentNames = [] } = options;\n\n  function traverse(node: TemplateChildNode): void {\n    if (node.type === 1) {\n      // NodeTypes.ELEMENT = 1\n      const element = node as ElementNode;\n\n      if (!shouldSkipElement(element.tag, ignoreComponentNames)) {\n        // Check if already has data-locatorjs attribute\n        const hasLocator = element.props.some(\n          (prop) =>\n            prop.type === 6 && // NodeTypes.ATTRIBUTE = 6\n            prop.name === \"data-locatorjs\"\n        );\n\n        if (!hasLocator && element.loc) {\n          // Create the locator attribute\n          const locatorValue = `${filename}:${element.loc.start.line}:${element.loc.start.column}`;\n\n          // Add the attribute to the element\n          const locatorAttr: AttributeNode = {\n            type: 6, // NodeTypes.ATTRIBUTE\n            name: \"data-locatorjs\",\n            value: {\n              type: 2, // NodeTypes.TEXT\n              content: locatorValue,\n              loc: element.loc,\n            },\n            loc: element.loc,\n            nameLoc: element.loc,\n          };\n\n          element.props.push(locatorAttr);\n        }\n      }\n\n      // Traverse children\n      if (element.children) {\n        for (const child of element.children) {\n          traverse(child);\n        }\n      }\n    } else if (node.type === 11) {\n      // NodeTypes.FOR = 11\n      // Handle v-for nodes\n      const forNode = node as any;\n      if (forNode.children) {\n        for (const child of forNode.children) {\n          traverse(child);\n        }\n      }\n    } else if (node.type === 9) {\n      // NodeTypes.IF = 9\n      // Handle v-if nodes\n      const ifNode = node as any;\n      if (ifNode.branches) {\n        for (const branch of ifNode.branches) {\n          if (branch.children) {\n            for (const child of branch.children) {\n              traverse(child);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Traverse all children of the root\n  for (const child of ast.children) {\n    traverse(child);\n  }\n}\n\n/**\n * Transform Vue SFC source code to inject source locations\n *\n * This function parses a .vue file, transforms the template,\n * and returns the modified source.\n */\nexport async function transformVueSFC(\n  code: string,\n  filename: string,\n  options: { ignoreComponentNames?: string[] } = {}\n): Promise<{ code: string; map?: any } | null> {\n  // Dynamic import to avoid requiring Vue as a hard dependency\n  let parse: typeof import(\"@vue/compiler-sfc\").parse;\n  let compileTemplate: typeof import(\"@vue/compiler-sfc\").compileTemplate;\n\n  try {\n    const sfc = await import(\"@vue/compiler-sfc\");\n    parse = sfc.parse;\n    compileTemplate = sfc.compileTemplate;\n  } catch {\n    console.warn(\n      \"[@bakdotdev/dev-tools] @vue/compiler-sfc not found. Vue support disabled.\"\n    );\n    return null;\n  }\n\n  const { descriptor, errors } = parse(code, {\n    filename,\n    sourceMap: true,\n  });\n\n  if (errors.length > 0) {\n    return null;\n  }\n\n  if (!descriptor.template) {\n    return null;\n  }\n\n  const templateContent = descriptor.template.content;\n  const templateStart = descriptor.template.loc.start.offset;\n\n  // Parse the template to get the AST\n  const { baseParse } = await import(\"@vue/compiler-core\");\n  const ast = baseParse(templateContent, {\n    getTextMode: () => 0,\n  });\n\n  // Transform the AST\n  transformVueTemplate(ast, {\n    filename,\n    ignoreComponentNames: options.ignoreComponentNames,\n  });\n\n  // We need to serialize the AST back to HTML\n  // Since Vue doesn't provide a built-in serializer, we'll use string manipulation\n  // based on source locations\n\n  // Collect all insertions we need to make\n  const insertions: Array<{ offset: number; content: string }> = [];\n\n  function collectInsertions(node: TemplateChildNode): void {\n    if (node.type === 1) {\n      const element = node as ElementNode;\n\n      // Find the data-locatorjs attribute we added\n      const locatorAttr = element.props.find(\n        (prop): prop is AttributeNode =>\n          prop.type === 6 &&\n          prop.name === \"data-locatorjs\" &&\n          !!(prop as AttributeNode).value?.content?.startsWith(filename)\n      ) as AttributeNode | undefined;\n\n      if (locatorAttr && locatorAttr.value) {\n        // Calculate where to insert the attribute (after the tag name)\n        const tagEnd = element.loc.start.offset + 1 + element.tag.length;\n        insertions.push({\n          offset: tagEnd,\n          content: ` data-locatorjs=\"${locatorAttr.value.content}\"`,\n        });\n      }\n\n      // Process children\n      if (element.children) {\n        for (const child of element.children) {\n          collectInsertions(child);\n        }\n      }\n    } else if (node.type === 11 || node.type === 9) {\n      const structural = node as any;\n      const children = structural.children || structural.branches?.flatMap((b: any) => b.children) || [];\n      for (const child of children) {\n        collectInsertions(child);\n      }\n    }\n  }\n\n  for (const child of ast.children) {\n    collectInsertions(child);\n  }\n\n  // Sort insertions by offset in reverse order (so we can insert without affecting earlier offsets)\n  insertions.sort((a, b) => b.offset - a.offset);\n\n  // Apply insertions to the template\n  let modifiedTemplate = templateContent;\n  for (const insertion of insertions) {\n    modifiedTemplate =\n      modifiedTemplate.slice(0, insertion.offset) +\n      insertion.content +\n      modifiedTemplate.slice(insertion.offset);\n  }\n\n  // Reconstruct the full SFC with the modified template\n  const before = code.slice(0, templateStart);\n  const after = code.slice(templateStart + templateContent.length);\n  const modifiedCode = before + modifiedTemplate + after;\n\n  return {\n    code: modifiedCode,\n  };\n}\n"],
  "mappings": "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",
  "names": []
}

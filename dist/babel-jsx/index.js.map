{
  "version": 3,
  "sources": ["../../src/babel-jsx/index.ts"],
  "sourcesContent": ["import { parse, parseExpression } from \"@babel/parser\";\nimport type { NodePath, Visitor } from \"@babel/traverse\";\nimport type * as BabelTypes from \"@babel/types\";\n\n// Inlined from isDisallowedComponent.ts to avoid ESM resolution issues\nconst disallowedNames: { [key: string]: true } = {\n  Fragment: true,\n  \"React.Fragment\": true,\n  Suspense: true,\n  \"React.Suspense\": true,\n};\n\n// React Three Fiber components use lowercase names that look like HTML but aren't\n// They don't support DOM attributes like data-locatorjs\nconst r3fPatterns = [\n  /^mesh$/,\n  /^group$/,\n  /^fog$/,\n  /^color$/,\n  /^ambientLight$/,\n  /^directionalLight$/,\n  /^pointLight$/,\n  /^spotLight$/,\n  /Geometry$/,\n  /Material$/,\n  /Helper$/,\n  /Controls$/,\n  /Camera$/,\n];\n\nfunction isDisallowedComponent(name: string) {\n  if (disallowedNames[name]) return true;\n  if (name.match(/Provider$/)) return true;\n  // Check R3F patterns\n  for (const pattern of r3fPatterns) {\n    if (pattern.test(name)) return true;\n  }\n  return false;\n}\n\n// Inline types that were previously imported from shared\ntype SourceLocation = {\n  start: { line: number; column: number };\n  end: { line: number; column: number };\n};\n\ntype ComponentInfo = {\n  name: string;\n  loc: SourceLocation | null;\n};\n\ntype ExpressionInfo = {\n  name: string;\n  loc: SourceLocation;\n  wrappingComponentId: number | null;\n};\n\ntype StyledDefinitionInfo = {\n  name: string | null;\n  loc: SourceLocation;\n  htmlTag: string;\n};\n\ntype FileStorage = {\n  filePath: string;\n  projectPath: string;\n  expressions: ExpressionInfo[];\n  styledDefinitions: StyledDefinitionInfo[];\n  components: ComponentInfo[];\n};\n\nexport interface PluginOptions {\n  opts?: {\n    env?: string;\n    target?: string;\n    runtime?: string;\n    ignoreComponentNames?: string[];\n    dataAttribute?: \"id\" | \"path\";\n  };\n  file: {\n    path: NodePath;\n  };\n  filename: string;\n  cwd: string;\n}\n\nexport interface Babel {\n  types: typeof BabelTypes;\n  env: () => string;\n}\n\nexport default function transformLocatorJsComponents(babel: Babel): {\n  visitor?: Visitor<PluginOptions>;\n} {\n  // there was some weird caching error when using babel.env() on Vite\n  // Vite has NODE_ENV undefined when doing first dev build\n  const env = process.env.BABEL_ENV || process.env.NODE_ENV || \"development\";\n\n  const t = babel.types;\n  let fileStorage: FileStorage | null = null;\n  let wrappingComponent: {\n    // id: number;\n    name: string;\n    locString: string;\n    loc: SourceLocation;\n  } | null = null;\n  let lastComponentId = 0;\n  let lastExpressionId = 0;\n  let lastStyledId = 0;\n  let currentWrappingComponentId: number | null = null;\n\n  function addExpressionToStorage(expression: ExpressionInfo) {\n    if (fileStorage) {\n      const id = lastExpressionId;\n      fileStorage.expressions[id] = expression;\n      lastExpressionId++;\n      return id;\n    } else {\n      throw new Error(\"No fileStorage\");\n    }\n  }\n\n  function addStyledToStorage(styled: StyledDefinitionInfo) {\n    if (fileStorage) {\n      const id = lastStyledId;\n      fileStorage.styledDefinitions[id] = styled;\n      lastStyledId++;\n      return id;\n    } else {\n      throw new Error(\"No fileStorage\");\n    }\n  }\n\n  function addComponentToStorage(component: ComponentInfo) {\n    if (fileStorage) {\n      const id = lastComponentId;\n      fileStorage.components[id] = component;\n      lastComponentId++;\n      return id;\n    } else {\n      throw new Error(\"No fileStorage\");\n    }\n  }\n\n  return {\n    visitor: {\n      Program: {\n        // TODO state is any, we should check if the state depends on webpack or what it depends on?\n        enter(path, state) {\n          function isLocallyDisallowedComponent(name: string) {\n            const opts = state?.opts?.ignoreComponentNames || [];\n            return opts.includes(name);\n          }\n\n          if (state.opts?.env) {\n            if (state.opts?.env !== env) {\n              return;\n            }\n          }\n\n          lastComponentId = 0;\n          lastExpressionId = 0;\n          lastStyledId = 0;\n          if (!state?.filename) {\n            throw new Error(\"No file name\");\n          }\n          if (state.filename.includes(\"node_modules\")) {\n            fileStorage = null;\n          } else {\n            // Check if the file is within the cwd\n            const isWithinCwd = state.filename.startsWith(state.cwd);\n            fileStorage = {\n              // If file is within cwd, make it relative; otherwise keep absolute path\n              filePath: isWithinCwd\n                ? state.filename.replace(state.cwd, \"\")\n                : state.filename,\n              // Only set projectPath if file is within cwd\n              projectPath: isWithinCwd ? state.cwd : \"\",\n              expressions: [],\n              styledDefinitions: [],\n              components: [],\n            };\n          }\n\n          // NEED TO RUN MANUAL TRAVERSE, SO IT MAKE EDITS BEFORE ALL OTHER PLUGINS\n          path.traverse({\n            // TODO add also for arrow function and class components\n            FunctionDeclaration: {\n              enter(path, state) {\n                if (!fileStorage) {\n                  return;\n                }\n                if (!path || !path.node || !path.node.id || !path.node.loc) {\n                  return;\n                }\n                const name = path.node.id.name;\n\n                wrappingComponent = {\n                  name,\n                  locString:\n                    path.node.loc.start.line + \":\" + path.node.loc.start.column,\n                  loc: path.node.loc,\n                };\n                currentWrappingComponentId =\n                  addComponentToStorage(wrappingComponent);\n              },\n              exit(path, state) {\n                if (!fileStorage) {\n                  return;\n                }\n                if (!path || !path.node || !path.node.id || !path.node.loc) {\n                  return;\n                }\n                const name = path.node.id.name;\n\n                // Reset wrapping component\n                if (\n                  wrappingComponent &&\n                  wrappingComponent.name === name &&\n                  wrappingComponent.locString ===\n                    path.node.loc.start.line + \":\" + path.node.loc.start.column\n                ) {\n                  wrappingComponent = null;\n                }\n              },\n            },\n            TaggedTemplateExpression(path) {\n              if (!fileStorage) {\n                return;\n              }\n              const tag = path.node.tag;\n              if (tag.type === \"MemberExpression\") {\n                const property = tag.property;\n                const object = tag.object;\n                if (\n                  object.type === \"Identifier\" &&\n                  object.name === \"styled\" &&\n                  property.type === \"Identifier\"\n                ) {\n                  let name = null;\n                  const parent = path.parent;\n                  if (parent.type === \"VariableDeclarator\") {\n                    if (parent.id.type === \"Identifier\") {\n                      name = parent.id.name;\n                    }\n                  }\n\n                  if (path.node.loc) {\n                    const id = addStyledToStorage({\n                      name: name,\n                      loc: path.node.loc,\n                      htmlTag: property.name,\n                    });\n                    path.node.tag = t.callExpression(\n                      t.memberExpression(tag, t.identifier(\"attrs\")),\n                      [\n                        t.arrowFunctionExpression(\n                          [],\n                          t.objectExpression([\n                            t.objectProperty(\n                              t.stringLiteral(\"data-locatorjs-styled\"),\n                              t.stringLiteral(createDataId(fileStorage, id))\n                            ),\n                          ])\n                        ),\n                      ]\n                    );\n                  }\n                }\n              }\n            },\n            JSXElement(path) {\n              if (!fileStorage) {\n                return;\n              }\n              function getName(\n                el:\n                  | BabelTypes.JSXIdentifier\n                  | BabelTypes.JSXMemberExpression\n                  | BabelTypes.JSXNamespacedName\n              ): string {\n                if (el.type === \"JSXIdentifier\") {\n                  return el.name;\n                } else if (el.type === \"JSXMemberExpression\") {\n                  return getName(el.object) + \".\" + el.property.name;\n                } else if (el.type === \"JSXNamespacedName\") {\n                  return el.namespace.name + \".\" + el.name.name;\n                }\n                return \"\";\n              }\n              const name = getName(path.node.openingElement.name);\n\n              if (\n                name &&\n                !isDisallowedComponent(name) &&\n                !isLocallyDisallowedComponent(name)\n              ) {\n                if (path.node.loc) {\n                  const dataAttributeMode = state?.opts?.dataAttribute || \"id\";\n\n                  // Always add to storage for window.__LOCATOR_DATA__\n                  const id = addExpressionToStorage({\n                    name: name,\n                    loc: path.node.loc,\n                    wrappingComponentId: currentWrappingComponentId,\n                  });\n\n                  let newAttr: BabelTypes.JSXAttribute;\n                  if (dataAttributeMode === \"path\") {\n                    // Generate data-locatorjs with full path\n                    newAttr = t.jSXAttribute(\n                      t.jSXIdentifier(\"data-locatorjs\"),\n                      t.jSXExpressionContainer(\n                        t.stringLiteral(\n                          createFullPathWithLocation(fileStorage, path.node.loc)\n                        )\n                      )\n                    );\n                  } else {\n                    // Default: generate data-locatorjs-id with ID\n                    newAttr = t.jSXAttribute(\n                      t.jSXIdentifier(\"data-locatorjs-id\"),\n                      t.jSXExpressionContainer(\n                        t.stringLiteral(\n                          // this is stored by projectPath+filePath because that's the only unique identifier\n                          createDataId(fileStorage, id)\n                        )\n                        // t.ObjectExpression([\n                        // ])\n                      )\n                    );\n                  }\n                  path.node.openingElement.attributes.push(newAttr);\n                }\n              }\n            },\n          });\n        },\n        exit(path, state) {\n          if (state.opts?.env) {\n            if (state.opts.env !== env) {\n              return;\n            }\n          }\n\n          if (!fileStorage) {\n            return;\n          }\n          const dataCode = JSON.stringify(fileStorage);\n\n          const dataAst = parseExpression(dataCode, {\n            sourceType: \"script\",\n          });\n\n          const insertCode = `(() => {\n            if (typeof window !== \"undefined\") {\n              window.__LOCATOR_DATA__ = window.__LOCATOR_DATA__ || {};\n              window.__LOCATOR_DATA__[\"${createFullPath(\n                fileStorage\n              )}\"] = ${dataCode};\n            }\n          })()`;\n\n          // `function __bindLocatorExpression(id) {\n          //   return require(\"@locator/runtime\").__bindLocatorExpression(${createFullPath(\n          //     fileStorage\n          //   )}, id);\n          // }`;\n\n          const insertAst = parseExpression(insertCode, {\n            sourceType: \"script\",\n          });\n\n          path.node.body.push(t.expressionStatement(insertAst));\n        },\n      },\n    },\n  };\n}\n\nfunction createDataId(fileStorage: FileStorage, id: number): string {\n  return createFullPath(fileStorage) + \"::\" + String(id);\n}\n\nfunction createFullPath(fileStorage: FileStorage): string {\n  return fileStorage.projectPath + fileStorage.filePath;\n}\n\nfunction createFullPathWithLocation(\n  fileStorage: FileStorage,\n  loc: SourceLocation\n): string {\n  return `${fileStorage.projectPath}${fileStorage.filePath}:${loc.start.line}:${loc.start.column}`;\n}\n"],
  "mappings": "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",
  "names": ["path", "state"]
}
